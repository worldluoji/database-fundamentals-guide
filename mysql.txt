Mysql是一种RDBMS(关系型)数据库， 由于其是开源的（oracle太贵），市场上的占有率也在不断提高。

1. 开启事务处理的主要两种方式：
	1）begin 开始一个事务， rollback 回滚事务 ， commit提交事务
	2）SET AOTOCOMMIT=1开启事务自动提交
补充Mysql事务的4个特性：
原子性:一个事务中的所有操作，要么全部完成，要么全部不完成。
一致性:事务开始和结束后，数据库完整性没有破坏。
隔离性:多个事务并发，数据不会因为并发而不一致。
持久性:事务结束后，对数据的修改是持久的。

2. char和varchar的区别
char是固定长度，char中的n最大长度是255个字符, 如果是utf8编码方式， 那么char类型占255 * 3个字节，存储时字符数没有达到定义的位数，会后面补齐空格入库; varchar是变长的（0-65535字节），没有达到定义的位数，也不会补齐。 
所以char速度更快，但是会浪费空间。

3. 存储过程
先编译，再执行。实际就是把sql语句编译后存储在数据库中，这样用户通过指定存储过程名字并给定参数即可执行。明显，存储过程有更快的速度，同时也符合组件化编程的思想。
使用方法详见create_procedure.sql. 
注意：1）Mysql以";"为分隔符，如果没有声明分隔符，则编译器会将存储过程当作SQL语句处理，编译会报错，所以之前delimiter ;;，结束后再还原回delimiter ; 2）如果有入参，就SET &p_in=1, CALL 存储过程名（@p_in）

4. 查看版本，字符集等
show variables like '%version%';
show variables like 'character_set%';

5. Mysql允许用关键字作为表名（最好不要）。例如admin作为表明时，查询这张表要select * from `admin`;比较反人类

6. 连接Mysql: mysql -u 用户名 -p -h Mysql服务器所在主机。下面就会让输入密码。

7. 什么是STRAIGHT_JOING? STRAIGHT_JOIN is similar to JOIN, except that the left table is always read before the right table. This can be used for those (few) cases for which the join optimizer puts the tables in the wrong order.
例子：select * from t1 straight_join t2 on (t1.a=t2.a);则t1时驱动表，t2是被驱动表，如果直接用inner join则编译器不一定按照这个顺序。
注意：
STRAIGHT_JOIN只适用于inner join，并不使用与left join，right join。（因为left join，right join已经代表指定了表的执行顺序）
尽可能让优化器去判断，因为大部分情况下mysql优化器是比人要聪明的。使用STRAIGHT_JOIN一定要慎重，因为啊部分情况下认为指定的执行顺序并不一定会比优化引擎要靠谱。

8. explain SQL语句 \G来分析一条SQL语句。 不加\G就是表格形式，加了就是列表形式。

9. Mysql中如果设置了主键值达到了上限，再insert语句是就会报主键冲突的错误，因此建议尽量将主键类型设置为8 个字节的 bigint unsigned（2^64-1）防止那么快达到上限.
如果没有设置primary key，那么mysql会自动生成一个自增的看不到的rowId, 其也是bitint unsigned，但是只用了6个字节。 达到上限后就会覆盖原来的行，循环。

10. update流程还涉及redo log和bin log两个重要的日志模块。 
其中，redo log是innodb特有的。 
redo log大小是固定的，从头写到尾又到头，是一个圈；bin log则是追加写，不会覆盖原来的。 
redo log相当于一个“粉板”， 在执行更新操作的时候，先写到redo log里，等到空闲的时候再写到磁盘；bin log用来恢复数据，可以恢复记录的任意一秒的数据。
为什么用bin log恢复数据？因为前面已经说了，redo log是innnodb用来优化性能和保证crash-safe的，而且会循环写覆盖，而bin log是追加写的。
Mysql innodb在update时，会先记录redo log， 再记录bin log,最后提交事务，是一个典型的两阶段提交。
innodb_flush_log_at_trx_commit设置为，表示redo log持久化到磁盘， 这样即使MySql异常重启后数据也不会丢失；sync_binlog 这个参数设置成 1 表示每次
事务的bin log都写到磁盘，则异常重启后bin log不会丢失。
bin log是逻辑日志，redo log是物理日志。逻辑日志可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；物理日志就只有“我”自己能用，别人没有共享我的“物理格式”

11. MyISAM把一张表的记录总数记到了磁盘上，所以count(*) 查询时直接读取总数的记录就OK了，有点是速度快，但是MyISAM不支持事务的。 而InnoDB则是一条一条记录取数，目的是为了保证多版本控制（MVVC）时数据的正确性。
InnoDB count(*)性能优化：1）. 可以单独一张表存放总数，增加时+1，删除时-1；如果使用redis等内存数据库，可能会统计不准确，要求不高时可以使用。
 2）. 应该尽量使用count(*), Mysql Innodb做了优化，速度count(*)约等于count(1)>count(id)>count(字段) 3）. 根据业务场景优化，比如统计A+B+C三次查询记录的
 总数，可以再查询记录把数量一起返回给前端，前端再加起来。

12 Mysql查看，修改隔离界别： select @@transaction_isolation; 默认值时可重复读。
set session transaction isolation level （level取值如下）
1）read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决
2）read committed：读取已经提交的数据 ：可以解决脏读 ---- oracle默认的
3）repeatable read：重读读取：可以解决脏读 和 不可重复读 ---mysql默认的
4）serializable：串行化：可以解决 脏读 不可重复读 和 幻读---相当于锁表

13 脏读：session A 看到了session B提交的数据(X->Y)，结果 B roll back了， A看到的Y就是脏数据。
   不可重复读：session A 看到session B提交事务（X->Y）前后的值不一样。
   幻读：同一个事务前后两次查询同一张表， 前后两次查询中间有插入操作，后一次查询出现了前一次查询没有的行。
   见幻读产生例子.png中的Q3


14.begin;
   select * from t where d=5 for update;
   commit;
 select for update会加一个写锁， 写锁在commit提交事务后释放。
