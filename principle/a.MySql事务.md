# MySql事务
数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。

## 开启事务处理的主要两种方式
- 1）begin 开始一个事务， rollback 回滚事务，commit 提交事务
- 2）SET AOTOCOMMIT=1 开启事务自动提交

<br>

## Mysql事务的4个特性：
- 原子性:一个事务中的所有操作，要么全部完成，要么全部不完成。
- 一致性:事务开始和结束后，数据库完整性没有破坏。
- 隔离性:多个事务并发，数据不会因为并发而不一致。
- 持久性:事务结束后，对数据的修改是持久的。

<br>

## MySql事务的隔离级别
Mysql查看隔离级别： 
```
select @@transaction_isolation; 默认值是可重复读。(Mariadb是 select @@session.tx_isolation;)
```
Mysql修改隔离级别： 
```
set session transaction isolation level
```
level取值如:
- 1）read uncommitted : 能读取到尚未提交事务的数据 ：哪个问题都不能解决
- 2）read committed：能读取已经提交事务的数据 ：可以解决脏读 ---- oracle默认的
- 3）repeatable read：可重复读：可以解决脏读 和 不可重复读 ---mysql默认的，即与事务启动时看到的一致。
假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。
到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。
你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。
这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。
- 4）serializable：串行化：可以解决 脏读 不可重复读 和 幻读，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。
当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

<br>

- 脏读：session A 看到了session B提交的数据(X->Y)，结果 B roll back了， A看到的Y就是脏数据。read uncommitted就会发生脏读。
- 不可重复读：session A 看到session B提交事务（X->Y）前后的值不一样。
- 幻读：同一个事务前后两次查询同一张表， 前后两次查询中间有插入操作，后一次查询出现了前一次查询没有的行。
见幻读产生例子.png中的Q3，这里要说明一下，在默认可重复读级别下，普通查询时快照读时看不到别的事务下的新增的记录，
只有在当前读（for update，读取到已经提交的记录的最新值）的情况下，才会出现幻读.