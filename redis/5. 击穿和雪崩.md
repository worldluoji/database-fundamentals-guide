# Redis 穿透、击穿、雪崩
Redis 的穿透、击穿、雪崩是分布式系统中的经典问题，本质都是因缓存失效导致数据库压力骤增，但触发机制和解决方案有显著差异。以下是综合技术原理与工程实践的解析：

---

### 🧩 一、核心概念与区别
| **问题类型** | **触发条件**                          | **攻击目标**       | **破坏范围**       | **典型场景**                |
|--------------|---------------------------------------|--------------------|--------------------|----------------------------|
| **缓存穿透** | 查询**不存在的数据**（缓存+DB均无）   | 整个数据库         | 全局性压力         | 恶意攻击（如伪造ID -1） |
| **缓存击穿** | **热点Key突然失效** + 高并发重建      | 单个热点数据       | 局部高压           | 秒杀商品缓存过期   |
| **缓存雪崩** | **大量Key同时失效**或Redis节点宕机    | 大量缓存数据       | 系统性崩溃         | 促销商品集体过期    |

> **通俗比喻**：  
> - **穿透**：伪造传单索要不存在的商品 → 店员反复白跑仓库  
> - **击穿**：茅台售罄瞬间，百人挤爆仓库门 → 单点塌陷  
> - **雪崩**：所有促销商品同时下架 → 超市被搬空

---

### ⚠️ 二、发生机制与风险分析
#### **1. 缓存穿透（Cache Penetration）**
- **根源**：恶意攻击或参数异常（如 `id=-1`），绕过缓存直击数据库。  
- **风险**：  
  - 数据库每秒承受数万无效查询，CPU飙升直至宕机；  
  - 小规模攻击即可瘫痪单机服务（如个人云服务器）。

#### **2. 缓存击穿（Cache Breakdown）**
- **根源**：热点Key（如热门商品）过期瞬间，并发请求集中重建缓存。  
- **风险**：  
  - 数据库单点承受突发流量（如10万QPS），连接池耗尽；  
  - 重建延迟导致请求超时，用户体验骤降。

#### **3. 缓存雪崩（Cache Avalanche）**
- **根源**：  
  - **时间同步**：批量缓存设置相同TTL（如凌晨0点集体失效）；  
  - **节点故障**：Redis集群宕机，请求全量穿透。  
- **风险**：  
  - 数据库瞬时压力超过承载极限（如峰值流量翻百倍）；  
  - 连锁反应引发服务熔断，系统全面崩溃。

---

### 🛡️ 三、解决方案与工程实践
#### **缓存穿透：拦截无效请求**
1. **参数校验**  
   - 接口层过滤非法值（如 `id≤0` 直接拦截）。  
2. **缓存空值（Null Caching）**  
   - 数据库查无结果时，缓存 `NULL` 并设短TTL（如30秒）：  
     ```java
     if (db.get(key) == null) redis.setex(key, 30, "NULL"); 
     ```
3. **布隆过滤器（Bloom Filter）**  
   - 前置过滤器拦截绝对不存在的数据（误判率可控在0.1%）：  
     ```python
     bf = BloomFilter(capacity=1000000, error_rate=0.001)
     if key not in bf: return "Invalid Request"
     ```

#### **缓存击穿：热点数据高可用**
1. **互斥锁（Mutex Lock）**  
   - 分布式锁（Redis `SETNX`）保证单线程重建，其余请求等待：  
     ```java
     if (redis.get(key) == null) {
         if (redis.setnx("lock_key", 1)) {
             redis.expire("lock_key", 10);  // 避免死锁
             value = db.get(key);            // 重建缓存
             redis.set(key, value);
             redis.del("lock_key");
         } else Thread.sleep(100);          // 重试
     }
     ```
2. **逻辑永不过期**  
   - 缓存不设TTL，后台异步更新（如定时任务刷新热点数据）。  
3. **提前续期**  
   - 在缓存过期前，异步线程主动刷新（如TTL剩余10%时）。

#### **缓存雪崩：分散失效风险**
1. **随机化TTL**  
   - 基础时间 + 随机偏移量，打散失效时间点：  
     ```java
     int expireTime = 3600 + new Random().nextInt(600); // 1小时±随机10分钟
     ```
2. **多级缓存架构**  
   - 本地缓存（Caffeine） + Redis 集群，双重屏障：  
     ```mermaid
     graph LR
       Request --> L1[本地缓存]
       L1 -->|命中| Response
       L1 -->|未命中| L2[Redis]
       L2 -->|命中| Response
       L2 -->|未命中| DB[数据库]
     ```
3. **熔断降级（Hystrix/Sentinel）**  
   - 监控数据库QPS，超阈值时返回兜底数据（如默认商品页）。  
4. **Redis高可用**  
   - 集群模式（Cluster） + 哨兵（Sentinel）自动故障转移。

---

### 💎 四、生产环境最佳实践
1. **防御组合拳**  
   - 穿透：`布隆过滤器 + 空值缓存`  
   - 击穿：`互斥锁 + 热点标记`  
   - 雪崩：`随机TTL + 多级缓存 + 熔断`  

2. **监控与告警**  
   - 关键指标：  
     - `缓存未命中率`（穿透风险）  
     - `Key集中失效数`（雪崩风险）  
     - `PENDING消息堆积`（击穿信号）  

3. **压测与预案**  
   - 模拟雪崩场景：强制让50% Key同时失效，验证数据库承压能力；  
   - 预案：快速扩容从库、切换只读模式。

---

### 💎 **总结**  
Redis缓存失效问题本质是**流量洪峰与资源防护的博弈**：  
- **穿透** → 重在拦截（布隆过滤器为盾）；  
- **击穿** → 重在消峰（分布式锁为闸）；  
- **雪崩** → 重在分流（多级缓存为网）。  
实际架构中需结合业务流量特征（如热点分布、数据规模），选择组合策略并持续优化。