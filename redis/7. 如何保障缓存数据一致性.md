# 如何保障缓存数据一致性
在分布式系统中，Redis 缓存与 MySQL 数据库的数据一致性保障是核心挑战之一。以下是结合技术原理与工程实践的完整解决方案，涵盖主流策略及适用场景：

---

### ⚙️ **一、数据不一致的核心原因**
1. **更新顺序问题**  
   - 先更新缓存后更新数据库：若数据库更新失败，缓存为脏数据。  
   - 先更新数据库后更新缓存：若缓存更新失败，后续读请求命中旧数据。  
2. **并发读写冲突**  
   - 线程 A 删除缓存 → 线程 B 查询数据库旧数据 → 线程 B 写入旧数据到缓存 → 线程 A 更新数据库，导致缓存与数据库不一致。  
3. **异步同步延迟**  
   - Binlog 同步、消息队列等异步方案存在短暂延迟，可能导致临时不一致。

---

### 🛡️ **二、主流解决方案及适用场景**
#### **1. 延迟双删策略（推荐读多写少场景）**  
- **流程**：  
  ① 删除 Redis 缓存 → ② 更新 MySQL → ③ 延迟 500ms~1s → ④ 再次删除 Redis。  
- **优势**：解决并发读写导致的脏缓存回填问题。  
- **代码示例**（Go）：  
  ```go
  func UpdateUser(userID int, name string) {
      cacheKey := fmt.Sprintf("user:%d", userID)
      redis.Del(cacheKey)                // 第一次删除
      mysql.Update("UPDATE users SET name=? WHERE id=?", name, userID)
      time.Sleep(500 * time.Millisecond)  // 延迟
      redis.Del(cacheKey)                // 第二次删除
  }
  ```
- **适用场景**：电商商品详情页、用户信息更新等允许短暂不一致的业务。

#### **2. 分布式锁强一致方案（强一致性要求）**  
- **流程**：  
  ① 获取分布式锁（如 Redis `SETNX`）→ ② 更新 MySQL → ③ 更新/删除 Redis → ④ 释放锁。  
- **优势**：彻底避免并发冲突，保证原子性。  
- **风险**：性能下降（锁竞争）、死锁风险。  
- **适用场景**：账户余额变更、库存扣减等对一致性敏感的金融操作。

#### **3. 异步最终一致性方案（高并发大系统）**  
- **方案一：消息队列（如 Kafka）**  
  - 流程：更新 MySQL → 发送消息 → 消费者更新 Redis。  
  - 保障：消息重试机制 + 死信队列确保最终一致。  
- **方案二：Binlog 同步（如 Canal）**  
  - 流程：MySQL 更新 → Canal 监听 Binlog → 解析变更 → 更新 Redis。  
  - 优势：业务无侵入，适合历史数据同步。  
- **适用场景**：社交动态、日志记录等允许延迟同步的业务。

#### **4. 缓存更新策略设计**  
| **策略**               | **原理**                              | **一致性强度** | **性能** |  
|------------------------|---------------------------------------|---------------|----------|  
| **Cache-Aside**        | 读时加载缓存，写时先更新 DB 再删缓存     | 最终一致      | 高       |  
| **Write-Through**      | 同时更新 DB 和缓存                     | 强一致        | 中       |  
| **Write-Behind**       | 先更新缓存，异步批量更新 DB             | 弱一致        | 极高     |  
- **选型建议**：  
  - 读多写少 → **Cache-Aside + 延迟双删**。  
  - 写多强一致 → **Write-Through + 分布式锁**。  
  - 高吞吐弱一致 → **Write-Behind**。

---

### ⚠️ **三、生产环境实践关键点**
1. **兜底策略**  
   - **缓存设置 TTL**（如 5~10 分钟），强制失效后重新加载。  
   - **布隆过滤器**拦截无效查询，避免缓存穿透。  
2. **监控与降级**  
   - 监控 Redis/MySQL 数据差异（如 `diff_key_count` 指标），超阈值报警。  
   - Redis 故障时降级直连 MySQL + 限流（如 Sentinel 熔断）。  
3. **并发优化**  
   - **热点 Key**：互斥锁（`SETNX`）控制单线程重建缓存。  
   - **缓存雪崩**：随机化 TTL（如 `基础时间 + rand(0, 600s)`）。

---

### 💎 **四、方案选型总结**
| **场景**                | **推荐方案**               | **一致性级别** | **复杂度** |  
|-------------------------|--------------------------|---------------|-----------|  
| 读多写少（如商品详情）    | 延迟双删 + Cache-Aside    | 最终一致      | 低        |  
| 强一致性（如支付、余额）  | 分布式锁 + Write-Through  | 强一致        | 高        |  
| 高并发写入（如点击统计）  | Write-Behind + 批量回写   | 最终一致      | 中        |  
| 老旧系统改造            | Binlog 同步（Canal）      | 准实时一致    | 高        |  

> **决策树**：  
> - 强一致性 → 分布式锁方案；  
> - 允许延迟 → 消息队列/Binlog；  
> - 简单业务 → 延迟双删 + TTL 兜底。

通过组合策略（如 **Binlog 同步 + 消息重试 + TTL 兜底**），可在一致性、性能、复杂度间取得最优平衡。实际落地需结合业务流量模型（如 QPS、数据热点分布）进行压测调优。